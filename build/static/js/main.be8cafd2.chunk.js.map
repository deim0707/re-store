{"version":3,"sources":["components/bookstore-service-context/bookstore-service-context.js","components/hoc/with-bookstore-service.js","components/book-list-item/index.js","components/book-list-item/book-list-item.js","actions/index.js","utils/compose.js","components/spinner/index.js","components/spinner/spinner.js","components/error-indicator/index.js","components/error-indicator/error-indicator.js","components/book-list/book-list.js","components/book-list/index.js","components/shopping-cart-table/shopping-cart-table.js","components/shopping-cart-table/index.js","components/pages/home-page.js","components/pages/cart-page.js","components/shop-header/index.js","components/shop-header/shop-header.js","components/app/index.js","components/app/app.js","components/error-boundry/index.js","components/error-boundry/error-boundry.js","services/bookstore-services.js","reducers/book-list.js","reducers/shopping-cart.js","reducers/index.js","store.js","index.js"],"names":["React","createContext","BookstoreServiceProvider","Provider","BookstoreServiceConsumer","Consumer","withBookstoreService","Wrapped","props","bookstoreService","BookListItem","book","onAddedToCart","title","author","price","coverImage","className","src","alt","href","onClick","fetchBooks","dispatch","type","getBooks","then","data","payload","catch","err","bookAddedToCart","bookId","compose","funcs","comp","reduceRight","wrapped","f","Spinner","ErrorIndicator","BookList","books","map","key","id","BookListContainer","this","loading","error","Component","connect","state","bookList","ownProps","mapDispatchToProps","onIncrease","onDecrease","onDelete","ShoppingCartTable","shoppingCart","items","cartItems","total","orderTotal","item","idx","count","HomePage","CartPage","ShopHeader","numItems","to","App","role","path","exact","component","ErrorBoundry","hasError","setState","children","BookstoreService","Promise","resolve","reject","setTimeout","updateBookList","action","undefined","updateCartItems","slice","updateOrder","quantity","find","itemIndex","findIndex","newItem","updateCartItem","updateShoppingCart","orderTotalItems","reducer","store","createStore","booksStoreService","ReactDOM","render","StrictMode","value","document","getElementById"],"mappings":"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","file":"static/js/main.be8cafd2.chunk.js","sourcesContent":["import React from 'react';\n\nconst {\n  Provider: BookstoreServiceProvider,\n  Consumer: BookstoreServiceConsumer\n} = React.createContext();\n\nexport {\n  BookstoreServiceProvider,\n  BookstoreServiceConsumer\n};\n","//используем этот HOC для большего удобства работы с контекстом (в котором передаём Сервис в другие компоненты)\nimport React from 'react';\nimport { BookstoreServiceConsumer } from '../bookstore-service-context';\n\nconst withBookstoreService = () => (Wrapped) => {\n\n  return (props) => {\n    return (\n      <BookstoreServiceConsumer>\n        {\n          (bookstoreService) => {\n            return (<Wrapped {...props}\n                     bookstoreService={bookstoreService}/>);\n          }\n        }\n      </BookstoreServiceConsumer>\n    );\n  }\n};\n\nexport default withBookstoreService;\n","import BookListItem from './book-list-item';\n\nexport default BookListItem;\n","import React from 'react';\nimport './book-list-item.css';\n\nconst BookListItem = ({book, onAddedToCart}) => {\n  const {title, author, price, coverImage} = book;\n  return (\n      <div className='book-list-item'>\n          <div className=\"book-cover\">\n              <img src={coverImage} alt={`cover of ${title}`}/>\n          </div>\n\n          <div className=\"book-details\">\n              <span href=\"#\" className='book-title'>{title}</span>\n              <div className='book-author'>{author}</div>\n              <div className='book-price'>${price}</div>\n              <button\n                  onClick={onAddedToCart}\n                  className='btn btn-info add-to-cart'>\n                  Add to cart\n              </button>\n          </div>\n      </div>\n  )\n};\n\n\nexport default BookListItem;\n","const booksRequested = () => {\r\n    return {type: 'FETCH_BOOKS_REQUEST'}\r\n};\r\n\r\nconst booksLoaded = (newBooks) => {\r\n    return {\r\n        type: 'FETCH_BOOK_SUCCESS',\r\n        payload: newBooks\r\n    }\r\n};\r\n\r\nconst booksError = (error) => {\r\n    return {\r\n        type: 'FETCH_BOOKS_FAILURE',\r\n        payload: error\r\n    }\r\n};\r\n\r\n//это не экшен. но уместно здесь хранить эту функцию, т.к. она работает с экшенами\r\nconst fetchBooks = (bookstoreService, dispatch) => () => {\r\n    dispatch(booksRequested()); //booksRequested поможет при заходе на страницу, например с другой внутренней, снова показать лоадер и загрузить книги\r\n    bookstoreService.getBooks()\r\n        .then( (data) => dispatch(booksLoaded(data)))\r\n        .catch( (err) => dispatch(booksError(err)))\r\n};\r\n\r\nconst bookAddedToCart = (bookId) => {\r\n    return {\r\n        type: 'BOOK_ADDED_TO_CART',\r\n        payload: bookId\r\n    }\r\n};\r\n\r\nconst bookRemovedToCart = (bookId) => {\r\n    return {\r\n        type: 'BOOK_REMOVED_FROM_CART',\r\n        payload: bookId\r\n    }\r\n};\r\n\r\nconst allBookRemovedToCart = (bookId) => {\r\n    return {\r\n        type: 'ALL_BOOKS_REMOVED_FROM_CART',\r\n        payload: bookId\r\n    }\r\n};\r\n\r\n//1) первый вариант. экспортировали всё наружу\r\n// export {\r\n//     booksLoaded, booksRequested, booksError, fetchBooks\r\n// }\r\n//2) но функция fetchBooks содержит все это экшены. и красивее экспортировать её одну. т.к. другие нам наруже просте не нужны\r\nexport {\r\n    fetchBooks,\r\n    bookAddedToCart, bookRemovedToCart, allBookRemovedToCart\r\n}\r\n\r\n","//функция Compose делает функциональную композицию из компонентов высшего порядка\r\n\r\nconst compose = (...funcs) => (comp) => {\r\n    return funcs.reduceRight(\r\n        (wrapped, f) => f(wrapped), comp);\r\n};\r\n\r\nexport default compose;","import Spinner from './spinner';\n\nexport default Spinner;\n","import React from 'react';\nimport './spinner.css';\n\nconst Spinner = () => {\n  return <div>loading...</div>;\n};\n\nexport default Spinner;\n","import ErrorIndicator from './error-indicator';\n\nexport default ErrorIndicator;\n","import React from 'react';\nimport './error-indicator.css';\n\nconst ErrorIndicator = () => {\n  return <div>Error!</div>;\n};\n\nexport default ErrorIndicator;\n","import React, {Component} from 'react';\nimport {connect} from 'react-redux';\nimport './book-list.css';\nimport {withBookstoreService} from \"../hoc\";\nimport BookListItem from \"../book-list-item\";\nimport {fetchBooks, bookAddedToCart} from \"../../actions\";\nimport {compose} from \"../../utils\";\nimport Spinner from \"../spinner\";\nimport ErrorIndicator from \"../error-indicator\";\n\nconst BookList = ({books, onAddedToCart}) => {\n  return (\n      <ul className='book-list'>\n        {\n          books.map((book)=> {\n            return (\n                <li key={book.id}>\n                  <BookListItem\n                      book={book}\n                      onAddedToCart={()=>onAddedToCart(book.id)}\n                  />\n                </li>\n            )\n          })\n        }\n      </ul>\n  )\n};\n\nclass BookListContainer  extends Component {\n  componentDidMount() {\n    this.props.fetchBooks(); //смотрим в самом конце у экспортом\n  }\n  render() {\n    const {books, loading, error, onAddedToCart} = this.props;\n\n    if (loading) {\n      return <Spinner/>\n    }\n\n    if (error) {\n      return <ErrorIndicator/>\n    }\n\n    return <BookList books={books} onAddedToCart={onAddedToCart}/>\n  }\n}\n\n\n\nconst mapStateToProps = state => {\n  return {\n    books: state.bookList.books,\n    loading: state.bookList.loading,\n    error: state.bookList.error\n  }\n};\n//второй вариант получения стейта с использованием деструктуризации\n// const mapStateToProps = ({books,loading}) => {\n//   return { books,loading }\n// };\n\n\n\n//1) в этом способе написали экшен сами\n// const mapDispatchToProps = (dispatch) => {\n//   return {\n//     booksLoaded: (newBooks) => {\n//       dispatch({\n//         type: 'BOOKS_LOADED',\n//         payload: newBooks\n//       })\n//     }\n//   }\n// };\n\n//2) тут подставили ранее написанный экшен\n// const mapDispatchToProps = (dispatch) => {\n//   return {\n//     booksLoaded: (newBooks) => {\n//       dispatch(booksLoaded(newBooks))\n//     }\n//   }\n// };\n\n//3) bindActionCreators (его нужно импортировать)\n// const mapDispatchToProps = (dispatch) => {\n//   return bindActionCreators({\n//     booksLoaded\n//   }, dispatch)\n// };\n\n//4) по умолчанию произойдёт действие из 3его пункта. такой редакс умный. даже импортировать bindActionCreator не надо\n// const mapDispatchToProps = {\n//   booksLoaded, booksRequested,booksError,\n// };\n\n// 5) рефакторинг в стиле Буры. тут вынесли логику из компонента. компонент отвечает за ренединг элементов\nconst mapDispatchToProps = (dispatch, ownProps) => { //ownProps достаёт доступные для Коннекта пропсы\n  const {bookstoreService} = ownProps;\n  return {\n    fetchBooks: fetchBooks(bookstoreService, dispatch),\n    onAddedToCart: (id)=> dispatch(bookAddedToCart(id))\n  }\n};\n\n\n//используем 2 компонента высшего порядка. один написан нами, для получения компонентами методов работы с \"сервером\". отсюда берём метод GetBooks()\n//второй редаксовский. в итоге наш компонент BookList обёрнут двумя другими компонентами\n// export default withBookstoreService()\n//   (connect(mapStateToProps, mapDispatchToProps)\n//     (BookList));\n\n//compose - делает композицию из 2ух компонентов высшего порядка. удобнее записывать\nexport default compose(\n    withBookstoreService(),\n    connect(mapStateToProps, mapDispatchToProps)\n) (BookListContainer)","import BookList from './book-list';\n\nexport default BookList;\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport {bookAddedToCart, bookRemovedToCart, allBookRemovedToCart} from '../../actions'\nimport './shopping-cart-table.css';\n\nconst ShoppingCartTable = ({ items, total, onIncrease, onDecrease, onDelete }) => {\n\n  const renderRow = (item, idx) => {\n    const { id, title, count, total } = item;\n    return (\n        <tr key={id}>\n          <td>{idx + 1}</td>\n          <td>{title}</td>\n          <td>{count}</td>\n          <td>${total}</td>\n          <td>\n            <button\n                onClick={() => onDelete(id)}\n                className=\"btn btn-outline-danger btn-sm float-right\">\n              <i className=\"fa fa-trash-o\" />\n            </button>\n            <button\n                onClick={() => onIncrease(id)}\n                className=\"btn btn-outline-success btn-sm float-right\">\n              <i className=\"fa fa-plus-circle\" />\n            </button>\n            <button\n                onClick={() => onDecrease(id)}\n                className=\"btn btn-outline-warning btn-sm float-right\">\n              <i className=\"fa fa-minus-circle\" />\n            </button>\n          </td>\n        </tr>\n    );\n  };\n\n  return (\n      <div className=\"shopping-cart-table\">\n        <h2>Your Order</h2>\n        <table className=\"table\">\n          <thead>\n          <tr>\n            <th>#</th>\n            <th>Item</th>\n            <th>Count</th>\n            <th>Price</th>\n            <th>Action</th>\n          </tr>\n          </thead>\n\n          <tbody>\n          { items.map(renderRow) }\n          </tbody>\n        </table>\n\n        <div className=\"total\">\n          {/*Total: ${total}*/}\n        </div>\n      </div>\n  );\n};\n//тут, в отличие от БукЛист закидываю значения из стейта при помощи деструктуризации\nconst mapStateToProps = ({shoppingCart: { cartItems, orderTotal }}) => {\n  return {\n    items: cartItems,\n    total: orderTotal\n  };\n};\n\nconst mapDispatchToProps = {\n    onIncrease: bookAddedToCart,\n    onDecrease: bookRemovedToCart,\n    onDelete: allBookRemovedToCart\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ShoppingCartTable);\n","import ShoppingCartTable from './shopping-cart-table';\n\nexport default ShoppingCartTable;\n","import React from \"react\";\r\nimport BookList from \"../book-list\";\r\nimport ShoppingCartTable from \"../shopping-cart-table\";\r\n\r\nconst HomePage = () => {\r\n\r\n\r\n    return (\r\n        <div>\r\n            <BookList/>\r\n            <ShoppingCartTable/>\r\n        </div>\r\n    )\r\n\r\n};\r\n\r\nexport default HomePage;","import React from \"react\";\r\n\r\nconst CartPage = () => {\r\n    return (\r\n        <div> Cart page</div>\r\n    )\r\n};\r\n\r\nexport default CartPage;","import ShopHeader from './shop-header';\n\nexport default ShopHeader;","import React from 'react';\nimport {Link} from \"react-router-dom\";\nimport {connect} from 'react-redux'\nimport './shop-header.css';\n\nconst ShopHeader = ({ numItems, total }) => {\n  return (\n    <header className=\"shop-header row\">\n        <Link to='/'>\n            <div className=\"logo text-dark\" href=\"#\">ReStore</div>\n\n        </Link>\n        <Link to='/cart'>\n            <div className=\"shopping-cart\">\n                <i className=\"cart-icon fa fa-shopping-cart\" />\n                {numItems} items\n                {/*(${total})*/}\n            </div>\n        </Link>\n    </header>\n  );\n};\n\nconst mapStateToProps = state => {\n    return {\n        total: state.shoppingCart.orderTotal,\n        numItems: state.shoppingCart.numItems\n    }\n\n};\n\n\n// const mapStateToProps = ({shoppingCart: { cartItems, orderTotal }}) => {\n//     return {\n//         items: cartItems,\n//         total: orderTotal\n//     };\n// };\nexport default connect(mapStateToProps)(ShopHeader);\n","import App from './app';\n\nexport default App;\n","import React from 'react';\nimport {Route, Switch} from \"react-router-dom\";\nimport './app.css';\nimport {withBookstoreService} from '../hoc';\n\nimport  {HomePage, CartPage} from '../pages';\nimport ShopHeader from \"../shop-header\";\n\n\nconst App = ({bookstoreService}) => {\n  return (\n      <main role='main' className='container'>\n          <ShopHeader/>\n          <Switch>\n              <Route path='/' exact component={HomePage}/>\n              <Route path='/cart' component={CartPage}/>\n\n          </Switch>\n      </main>\n  )\n};\n\nexport default withBookstoreService()(App);\n","import ErrorBoundry from './error-boundry';\n\nexport default ErrorBoundry;\n","import React, { Component } from 'react';\nimport ErrorIndicator from '../error-indicator';\n\nexport default class ErrorBoundry extends Component {\n\n  state = {\n    hasError: false\n  };\n\n  componentDidCatch() {\n    this.setState({ hasError: true });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <ErrorIndicator />;\n    }\n\n    return this.props.children;\n  }\n}","export default class BookstoreService {\r\n     data = [\r\n         {\r\n             id: 1,\r\n             title: 'Production-Ready Microservices',\r\n             author: 'Susan J. Fowler',\r\n             price: 32,\r\n             coverImage: 'https://images-na.ssl-images-amazon.com/images/I/41yJ75gpV-L._SX381_BO1,204,203,200_.jpg'},\r\n         {\r\n             id: 2,\r\n             title: 'Release It!',\r\n             author: 'Michael T. Nygard',\r\n             price: 45,\r\n             coverImage: 'https://images-na.ssl-images-amazon.com/images/I/414CRjLjwgL._SX403_BO1,204,203,200_.jpg'}\r\n     ];\r\n\r\n    getBooks() {\r\n        return new Promise(((resolve, reject) => { //этим Promise + задержкой делаем вид, что получаем данные с сервера\r\n            setTimeout(()=> {\r\n                resolve(this.data)\r\n                // reject(new Error('Something went wrong')) //проверка, сработает ли отлов ошибок\r\n            }, 700)\r\n        }))\r\n    }\r\n\r\n}","//функции написанны для простоты кода. далее используются в редюсере. объединяют в себе работу с определённой частью стейта\r\nconst updateBookList = (state, action) => {\r\n\r\n    if (state === undefined) {\r\n        return {\r\n            books: [],\r\n            loading: true,\r\n            error: null\r\n        }\r\n    }\r\n\r\n    switch (action.type) {\r\n        case 'FETCH_BOOKS_REQUEST': {\r\n            return {\r\n                books: [],\r\n                loading: true,\r\n                error: null\r\n            }\r\n        }\r\n\r\n        case 'FETCH_BOOK_SUCCESS':\r\n            return {\r\n                books: action.payload,\r\n                loading: false,\r\n                error: null\r\n            };\r\n\r\n        case 'FETCH_BOOKS_FAILURE': {\r\n            return {\r\n                books: [],\r\n                loading: false,\r\n                error: action.payload\r\n            }\r\n        }\r\n\r\n        default:\r\n            return state.bookList;\r\n    }\r\n\r\n};\r\n\r\nexport default updateBookList;","//функции для чистоты кода в редюсере\r\nconst updateCartItems = (cartItems, item, idx) => {\r\n    //удаление элемента в корзине, если ушли в минус по их числу\r\n    if(item.count===0) {\r\n        return [\r\n            ...cartItems.slice(0, idx),//от начала массива до выбранного индекса он буде как раньше\r\n            ...cartItems.slice(idx +1) //после вставляем старую часть. после нового индекса\r\n        ]\r\n    }\r\n\r\n    if (idx === -1) { //если индекс -1, то есть у нас новый элемент. то возвращаем новый массив. который состоит из всех элемент cartItems и новый эллемент\r\n        return [...cartItems, item]\r\n    }\r\n    //если индекс любое другое число. то обновляем существующий\r\n    return [\r\n        ...cartItems.slice(0, idx),//от начала массива до выбранного индекса он буде как раньше\r\n        item, //вставим наш новый элемент\r\n        ...cartItems.slice(idx +1) //после вставляем старую часть. после нового индекса\r\n    ]\r\n};\r\n\r\nconst updateCartItem = (book, item = {}, quantity) => {\r\n    //тут либо значения из существоющего айтема, либо первого выбранного*\r\n    const {\r\n        id = book.id,\r\n        count=0,\r\n        title=book.title,\r\n        total=0} = item;\r\n\r\n    return {\r\n        id,\r\n        title,\r\n        count: count + quantity,\r\n        total: total + quantity*book.price\r\n    }\r\n\r\n    //ИННОЕ НАПИСАНИЕ ЭТОЙ ФУНКЦИИ\r\n    //если у нас есть старый айтем (если айтем не равен undefined, т.к. при индексе -1 будет undefined), то, создаём новый на основании старого\r\n    // if (item) {\r\n    //     //тут мы берём все из уже существующей книги, и меняем только пару полей\r\n    //     return  {\r\n    //         ...item,\r\n    //         count: item.count+1,\r\n    //         total: item.total + book.price\r\n    //     };\r\n    // }\r\n    // else {             //если нет, то создаём новый\r\n    //     return  {\r\n    //         id: book.id,\r\n    //         title: book.title,\r\n    //         count: 1,\r\n    //         total: book.price\r\n    //     };\r\n    // }\r\n};\r\n\r\nconst updateOrder = (state, bookId, quantity) => {\r\n    const book = state.bookList.books.find((book) => book.id===bookId);\r\n    //проверка на наличие в корзине элемента с которым работаем\r\n    const itemIndex = state.shoppingCart.cartItems.findIndex(({id})=> id === bookId); //айди элемента, если он уже есть в списке (если нет, то вернёт -1)\r\n    const item = state.shoppingCart.cartItems[itemIndex];\r\n    const newItem = updateCartItem(book, item, quantity);\r\n    const numItemsNow = state.shoppingCart.numItems; //колличество товаров в корзине\r\n    //тут когда-то должен появиться подсчёт всей суммы заказа\r\n    // let orderItem = 0;\r\n    // if(!item && state.shoppingCart.orderTotal === 0) {\r\n    //     orderItem = newItem.total;\r\n    // }\r\n    // let orderItem1 = state.shoppingCart.cartItems[0] ? state.shoppingCart.cartItems[0].total : 0;\r\n    // let orderItem2 = state.shoppingCart.cartItems[1] ? state.shoppingCart.cartItems[1].total : 0;\r\n    //\r\n    // if(itemIndex<-1) {\r\n    //     orderItem = orderItem1 + orderItem2\r\n    // }\r\n    // // console.log(orderItem1 + '     ' + orderItem2 + '     ' +  orderItem)\r\n    // console.log(state.shoppingCart)\r\n\r\n//////////////////////\r\n    return {\r\n        numItems: numItemsNow+quantity,\r\n        orderTotal: 0,\r\n        cartItems: updateCartItems(state.shoppingCart.cartItems, newItem, itemIndex)\r\n    }\r\n};\r\n\r\n\r\n//функции написанны для простоты кода. далее используются в редюсере. объединяют в себе работу с определённой частью стейта\r\nconst updateShoppingCart = (state, action) => {\r\n\r\n    if (state === undefined) {\r\n        return {\r\n            cartItems: [],\r\n            orderTotalItems: 0,\r\n            orderTotal: 0,\r\n            numItems: 0\r\n        }\r\n    }\r\n\r\n    switch (action.type) {\r\n        case 'BOOK_ADDED_TO_CART': {\r\n            return updateOrder(state, action.payload, 1)\r\n        }\r\n\r\n        case 'BOOK_REMOVED_FROM_CART': {\r\n            return updateOrder(state, action.payload, -1)\r\n        }\r\n\r\n        case 'ALL_BOOKS_REMOVED_FROM_CART': {\r\n            const item = state.shoppingCart.cartItems.find(({id}) => id === action.payload);\r\n            return updateOrder(state, action.payload, -item.count)\r\n        }\r\n\r\n        default:\r\n            return state.shoppingCart;\r\n    }\r\n};\r\n\r\nexport default updateShoppingCart;","import updateBookList from \"./book-list\";\r\nimport updateShoppingCart from \"./shopping-cart\";\r\n\r\n\r\nconst reducer = (state, action) => {\r\n    //console.log(action.type); //какой экшен поступил в редюсер\r\n\r\n    return {\r\n        bookList: updateBookList(state, action),\r\n        shoppingCart: updateShoppingCart(state, action)\r\n    }\r\n};\r\n\r\nexport default reducer;","import {createStore, applyMiddleware} from \"redux\";\r\nimport thunkMiddleware from 'redux-thunk';\r\nimport reducer from \"./reducers\";\r\n\r\n//enhancer - меняет весь процесс. в т.ч. создание стор и диспатч\r\n//middleware - может поменять Только диспатч\r\n\r\n//под next в этих случаях обычно понимают dispatch. следующий в цепочке dispatch\r\n// const logMiddleware = (store) => (next) => (action) => {\r\n//     console.log(action.type, store.getState());\r\n//     return next(action);\r\n// };\r\n// //аналог функции ниже, с использованием не enhancer, a middleware\r\n// const stringMiddleware = () => (next) => (action) => {\r\n//     if (typeof  action === 'string') {\r\n//         return next({\r\n//             type: action\r\n//         })\r\n//     }\r\n//     else {\r\n//         return next(action)\r\n//     }\r\n// };\r\n\r\n//заменяем механизм создания стор. принимает createStore и возвращает его новую релизацию. метод: enhancer. паттерн функционального программирование. менее популярный, нежели middleware. уже существует множество таких библиотек.\r\n// const stringEnhancer = (createStore) => (...args) => {\r\n//     const store = createStore(...args);\r\n//\r\n//     //здесь наш оригинанльный диспэтч\r\n//     const originalDispatch = store.dispatch;\r\n//     //модифицируем dispath, учим его принимать не только объекты, но и строки\r\n//     store.dispatch = (action) => {\r\n//         if (typeof  action === 'string') {\r\n//             return originalDispatch({\r\n//                 type: action\r\n//             })\r\n//         }\r\n//         else {\r\n//             return originalDispatch(action)\r\n//         }\r\n//     };\r\n//     return store;\r\n// };\r\n\r\n\r\n\r\nconst store = createStore(reducer);\r\n// const store = createStore(reducer, applyMiddleware(thunkMiddleware,stringMiddleware, logMiddleware));\r\n//\r\n// //демонастрация работы с библиотекой thunk. позволит класть в диспетч не только объект, но и функцию\r\n// const delayedActionCreator = (timeOut) => (dispatch) => {\r\n//     setTimeout(() => dispatch({\r\n//         type: 'DELAY_ACTION'\r\n//     }), timeOut)\r\n// };\r\n// store.dispatch(delayedActionCreator(2500));\r\n\r\n\r\n//проверяем, что наше преобразование диспетча работает. и приложение не крашится\r\n// store.dispatch('HELLO_WORLD');\r\n\r\n\r\nexport default store;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {Provider} from 'react-redux';\nimport {HashRouter as Router} from \"react-router-dom\";\nimport App from \"./components/app\";\nimport ErrorBoundry from \"./components/error-boundry\"; //ловит ошибки при помощи ComponentDidCatch\nimport BookstoreService from \"./services/bookstore-services\";\nimport {BookstoreServiceProvider} from \"./components/bookstore-service-context\"; // HOC с контекстом, передаёт методы работы с \"сервером\"\nimport store from \"./store\";\n\nconst booksStoreService = new BookstoreService();\n\nReactDOM.render(\n  <React.StrictMode>\n      <Provider store={store}>\n          <ErrorBoundry>\n              <BookstoreServiceProvider value={booksStoreService}>\n                  <Router>\n                      <App/>\n                  </Router>\n              </BookstoreServiceProvider>\n          </ErrorBoundry>\n      </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}